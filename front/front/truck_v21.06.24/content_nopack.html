<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Boxes</title>
        <script src="https://arguv.com/ar_ba/custom/bab/24/dat.gui.min.js"></script>
        <script src="https://arguv.com/ar_ba/custom/bab/24/babylon.js"></script>
        <script src="https://arguv.com/ar_ba/custom/bab/24/babylonjs.materials.min.js"></script>
        <script src="https://arguv.com/ar_ba/custom/bab/24/babylonjs.loaders.js"></script>
        <script src="https://arguv.com/ar_ba/custom/bab/24/babylon.gui.min.js"></script>
		<script src="jquery-1.11.1.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>

        
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        
        BABYLON.AbstractMesh.prototype.spin = function (axis, rads, speed) {
            var ease = new BABYLON.CubicEase();
            ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
        	BABYLON.Animation.CreateAndStartAnimation('at4', this, 'rotation.' + axis, speed, 120, this.rotation[axis], this.rotation[axis]+rads, 0, ease);
        }       
        
          var createScene = async function () {
        
            var scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 3, 2000, new BABYLON.Vector3(0, 300, 0), scene);
          //  camera.setPosition(new BABYLON.Vector3(Math.PI / 2, Math.PI / 4, 2000));

            camera.attachControl(canvas, true);
      //      camera.zoomToMouseLocation = true;
            camera.wheelDeltaPercentage = 0.02;
            camera.panningSensibility = 5;


           // camera.lowerBetaLimit = 0.1;
          //  camera.upperBetaLimit = 2;
            camera.lowerRadiusLimit = 150;
            camera.upperRadiusLimit = 3500;
          //  camera.upperBetaLimit = Math.PI / 2.2;

            camera.upperBetaLimit = (Math.PI / 2) * 0.99;
        
            // Light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(-1, 1, -1));
            light.intensity = 1.5;


            //Materials
            var groundMaterial = new BABYLON.GridMaterial("groundMaterial", scene);
        	groundMaterial.majorUnitFrequency = 1;
        //	groundMaterial.minorUnitVisibility = 0.9;
        	groundMaterial.gridRatio = 100;
        	groundMaterial.opacity = 0.0;
            groundMaterial.useMaxLine = true;
        

            /*************************************Meshes****************************************/

            //truck
            let alphaMatTruck = 0.4;
            truckMaterial = new BABYLON.StandardMaterial("boxMat", scene);
            truckMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4, 0.1);
            truckMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
            truckMaterial.alpha = alphaMatTruck;

            //floor
            let alphaMatFloor = 0.4;
            floorMaterial = new BABYLON.StandardMaterial("boxMat", scene);
            floorMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4, 0.1);
            floorMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
            floorMaterial.alpha = alphaMatFloor;


            let truckWidth = 1650;
            let truckHeight = 260;
            let truckDepth = 245;

            let floorWidth = 1650;
            let floorHeight = 10;
            let floorDepth = 245;


            let truck = BABYLON.MeshBuilder.CreateBox("truck", {width: truckWidth, height: truckHeight, depth: truckDepth }, scene);
            truck.position = new BABYLON.Vector3(0, truckHeight/2, 0);
            truck.isPickable = false; 
            truck.material = truckMaterial;
            truck.material.backFaceCulling = false;
         //   truck.showBoundingBox = true;
            truck.enableEdgesRendering();	
            truck.edgesWidth = 200.0;
            truck.edgesColor = new BABYLON.Color4(0, 0, 0, 0.5);

            let floor = BABYLON.MeshBuilder.CreateBox("floor", {width: floorWidth, height: floorHeight, depth: floorDepth }, scene);
            floor.position = new BABYLON.Vector3(0, floorHeight/2, 0);
            floor.isPickable = false; 
            floor.material = floorMaterial;
            floor.material.backFaceCulling = false;



            let lorryWeelX = truck.getBoundingInfo().boundingBox.maximum.x; // move lorry and weel
   //         if (lorryWeelX < 350) {lorryWeelX = 350};


            let weelPosition = 50;
            let boxWeelMove = BABYLON.MeshBuilder.CreateBox("boxWeelMove", {}, scene); // for moving weel
            boxWeelMove.position = new BABYLON.Vector3(weelPosition - lorryWeelX, -150, 0); 

              let weel = BABYLON.SceneLoader.ImportMeshAsync("", "", "weel.glb", scene).then((resultWeel) => {
               resultWeel.meshes[0].scaling = new BABYLON.Vector3(-100, -100, -100, true);
               resultWeel.meshes[0].rotation = new BABYLON.Vector3(0, 0, Math.PI);
               resultWeel.meshes[0].position = new BABYLON.Vector3(weelPosition - lorryWeelX, -150, 0); 
               resultWeel.meshes[0].setParent(boxWeelMove);

               resultWeel.meshes[0].getDescendants().forEach((mesh)=>{
               mesh.isPickable = false; 
            })                
            }); 

            let lorryPosition = -400;
            let boxLorryMove = BABYLON.MeshBuilder.CreateBox("boxWeelMove", {}, scene); // for moving lorry
            boxLorryMove.position = new BABYLON.Vector3(lorryPosition + lorryWeelX, -150, 0); 


            let lorry = BABYLON.SceneLoader.ImportMeshAsync(null,"", "lorry.glb", scene).then((model) => {
            model.meshes[0].scaling = new BABYLON.Vector3(-100, -100, -100);  
            model.meshes[0].rotation = new BABYLON.Vector3( 0,  0, Math.PI);            
            model.meshes[0].position = new BABYLON.Vector3(lorryPosition + lorryWeelX, -150, 0); 
            model.meshes[0].setParent(boxLorryMove);

            model.meshes[0].getDescendants().forEach((mesh)=>{
            mesh.isPickable = false; 
            })   
             });
 

            // Ground
            var ground = BABYLON.MeshBuilder.CreateGround("ground", {width:4800, height:4800}, scene, false);
            ground.material = groundMaterial;


            ///////////Create dynamic texture start
            var textureResolution = 512;


        	let textureGround = [];   
        	let textureContext = [];   
        	let materialGround = []; 

            //Add text to dynamic texture
            var font = "bold 77px monospace";
            ///////////Create dynamic texture end

            let boxMat = [];

          let boxWidth = [197, 197, 197, 122, 122, 150, 129, 129, 117, 105];
          let boxHeight = [179, 179, 179, 122, 122, 155, 135, 110, 108, 127];
          let boxDepth = [197, 197, 197, 197, 197, 150, 153, 152, 168, 155];
          let boxName = [ "PO#2457", "PO#2458", "PO#2459", "PO#2460", "PO#2461", "PO#2462", "PO#2463", "PO#2464", "PO#2465", "PO#2466"];
          let boxWeight = [2, 2, 3, 3, 3, 4, 5, 6, 7, 8];


//////////////////////// boxes size start

function createTextSizeBoxes(font_size, planeHeight, text, x, y, z, al, be, ga) {
  //  var font_size = 48;                                //Set font
	  var font = "bold " + font_size + "px Arial";
  //  var planeHeight = 300;                             //Set height for plane
    var DTHeight = 1.5 * font_size;                    //Set height for dynamic texture or set as wished
    var ratio = planeHeight/DTHeight;                  //Calcultae ratio
  //  var text = "128";	                                 //Set text
	//Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
    var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
	  var tmpctx = temp.getContext();
	  tmpctx.font = font;
    var DTWidth = tmpctx.measureText(text).width + 8;
    var planeWidth = DTWidth * ratio;      //Calculate width the plane has to be 
    //Create dynamic texture and write the text
    var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", {width:DTWidth, height:DTHeight}, scene, false);
    var mat = new BABYLON.StandardMaterial("mat", scene);
    mat.diffuseTexture = dynamicTexture;
    dynamicTexture.drawText(text, null, null, font, "#ffffff", "#000000", true);
    //Create plane and set dynamic texture as material
    var plane = BABYLON.MeshBuilder.CreatePlane("plane", {width:planeWidth, height:planeHeight}, scene);
    plane.position = new BABYLON.Vector3(x, y, z);
    plane.rotation = new BABYLON.Vector3(al, be, ga);
    plane.material = mat;
    return plane;
}

//////////////////////// boxes size end




            // boxes Meshes
            function randomIntFromInterval(min, max) { // min and max included
             return Math.floor(Math.random() * (max - min + 1) + min);
             }

            let randomBox = [];
            let randomBoxSum = 0; 
            let mCyrcle = 0;   

            function createBoxes(boxWidth_f, boxHeight_f, boxDepth_f, boxName_f, boxWeight_f) {
            randomBoxSum = boxName.length; // summ of boxes            
             for (let i = 0; i < randomBoxSum; i++) {
                randomBox[mCyrcle] = BABYLON.MeshBuilder.CreateBox(`randomBox${mCyrcle}`, {
                width: Math.ceil(boxWidth_f[i]), height: Math.ceil(boxHeight_f[i]), depth: Math.ceil(boxDepth_f[i]),}, scene);
                     textureGround[mCyrcle] = new BABYLON.DynamicTexture("dynamic texture", {width:512, height:256}, scene);   
                     textureContext[mCyrcle] = textureGround[mCyrcle].getContext();
        	           materialGround[mCyrcle] = new BABYLON.StandardMaterial("Mat", scene); 
                 materialGround[mCyrcle].diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                 materialGround[mCyrcle].specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                 materialGround[mCyrcle].emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());            
                      materialGround[mCyrcle].diffuseTexture = textureGround[mCyrcle]; 
                      randomBox[mCyrcle].material = materialGround[mCyrcle];
                 randomBox[mCyrcle].material.diffuseTexture.drawText(`${boxName_f[mCyrcle]}`, 100, 150, font, "black", "white", true, true);
          
                 meshWidth = createTextSizeBoxes(48, boxWidth_f[i]/5, boxWidth_f[i], boxWidth[mCyrcle]/4, boxHeight_f[i]/2 + 0.4, - boxDepth_f[i]/2 + boxWidth_f[i]/10, Math.PI/2, Math.PI, 0); 
                 meshWidth.isPickable = false; 
                 meshWidth.parent = randomBox[mCyrcle];

                 meshDepth = createTextSizeBoxes(48, boxDepth_f[i]/5, boxDepth_f[i], boxWidth_f[i]/2 - boxDepth_f[i]/10, boxHeight_f[i]/2 + 0.4, 0, Math.PI/2, -Math.PI/2, 0); 
                 meshDepth.isPickable = false; 
                 meshDepth.parent = randomBox[mCyrcle];                

               var maxboxWidth_f = Math.max(...boxWidth_f);
                 var maxboxDepth_f = Math.max(...boxDepth);
                 randomBox[mCyrcle].position = new BABYLON.Vector3(maxboxWidth_f*(mCyrcle)/4-500, boxHeight_f[i]/2, maxboxDepth_f*(mCyrcle%4)+300); 
               mCyrcle = mCyrcle + 1;

             }
             }
             createBoxes (boxWidth, boxHeight, boxDepth, boxName, boxWeight);                       


/////////////////////  engine
            var startingPoint;
            var currentMesh;
        
            var getGroundPosition = function () {
                var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == ground; });
                if (pickinfo.hit) {
                    return pickinfo.pickedPoint;
                }
                return null;
            }
            
            var pointerDown = function (mesh) {
                    currentMesh = mesh;
                    startingPoint = getGroundPosition();
                    if (startingPoint) { // we need to disconnect camera from canvas
                        setTimeout(function () {
                            camera.detachControl(canvas);
                        }, 0);
                    }
            }
        
            var pointerUp = function () {
                if (startingPoint) {
                    camera.attachControl(canvas, true);
                    startingPoint = null;
                    return;
                }
            }
        
            var pointerMove = function () {
                if (!startingPoint) {
                    return;
                }
                   var current = getGroundPosition();
                    if (!current) {
                      return;
                   }
        
                var diff = current.subtract(startingPoint);
                currentMesh.position.addInPlace(diff);
                startingPoint = current;
            }

            var showSize = function () {
              inputText_box_Z.text = currentMesh.getBoundingInfo().boundingBox.maximum.z * 2;
              inputText_box_Y.text = currentMesh.getBoundingInfo().boundingBox.maximum.y * 2;
              inputText_box_X.text = currentMesh.getBoundingInfo().boundingBox.maximum.x * 2;
              inputText_box_place.text = boxName[currentMesh.name.slice(currentMesh.name.lastIndexOf('currentMesh.name') + 10)];
              inputText_box_weight.text = boxWeight[currentMesh.name.slice(currentMesh.name.lastIndexOf('currentMesh.name') + 10)];

     //         console.log(currentMesh);
    //          console.log(currentMesh.name.indexOf('randomBox'));
    //          console.log(currentMesh.name.slice(currentMesh.name.lastIndexOf('currentMesh.name') + 10));
    //          console.log( boxName[currentMesh.name.slice(currentMesh.name.lastIndexOf('currentMesh.name') + 10)]);
    //          console.log( boxWeight[currentMesh.name.slice(currentMesh.name.lastIndexOf('currentMesh.name') + 10)]);

            }


            scene.onPointerObservable.add((pointerInfo) => { 
                switch (pointerInfo.type) {
        			case BABYLON.PointerEventTypes.POINTERDOWN:
        				if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh != ground 
                        && pointerInfo.pickInfo.pickedMesh != truck
                        && pointerInfo.pickInfo.pickedMesh != floor
                        && pointerInfo.pickInfo.pickedMesh != weel
                        && pointerInfo.pickInfo.pickedMesh != lorry
                        && pointerInfo.pickInfo.pickedMesh != meshDepth
                        && pointerInfo.pickInfo.pickedMesh != meshWidth                     
                    ) {         
                            pointerDown(pointerInfo.pickInfo.pickedMesh)  // pic up mesh
                            showSize();
                          //  console.log(currentMesh.getBoundingInfo().boundingBox.maximum.y);                        
                         scene.onBeforeRenderObservable.add(() => {  
                            randomBox.sort((a,b)=>( a.position.y - b.position.y )) // kod work mach better
                               randomBox.forEach(function(item, index, array) {                             
                                 if (  !currentMesh.intersectsMesh(item)) {        // put to ground  
                                 currentMesh.position.y = currentMesh.getBoundingInfo().boundingBox.maximum.y; 
                                    } 
                               }); 
                               randomBox.forEach(function(item, index, array) {    // lift box        
                         //       item.getBoundingInfo().boundingBox.minimumWorld._y == currentMesh.getBoundingInfo().boundingBox.minimumWorld._y
                                 if ( currentMesh.intersectsMesh(item) && currentMesh !== item ) {
                                    currentMesh.position.y = item.getBoundingInfo().boundingBox.maximumWorld.y + currentMesh.getBoundingInfo().boundingBox.maximum.y;
                                    }
                               }); 
                        }); 
                        }
        				break;
        			case BABYLON.PointerEventTypes.POINTERUP:
                            pointerUp();  // let free mesh
        				break;
        			case BABYLON.PointerEventTypes.POINTERMOVE:          
                            pointerMove();  // move mesh
        				break;
                }

        
        });

 /////////////////////  engine  
 
    // Keyboard events

        scene.onBeforeRenderObservable.add(() => {

          window.addEventListener("keydown", async (ev) => {
        // Q, q
           if (ev.keyCode === 81) {
            currentMesh.spin("y", Math.PI/2, 1000);
            currentMesh.refreshBoundingInfo();
            keydown = true;           
           }
          });

       });
            
/*
        if (BABYLON.VideoRecorder.IsSupported(engine)) {
        var recorder = new BABYLON.VideoRecorder(engine);
        recorder.startRecording("test.webm", 15);
         }
*/


       /////////////////right gui start
    let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI", true, scene);
    let loadedGUI = await advancedTexture.parseFromURLAsync("guiTexture.json");

    let buttonLorry_1 = advancedTexture.getControlByName("ButtonLorry_1"); 
    let buttonLorry_2 = advancedTexture.getControlByName("ButtonLorry_2");   
    let buttonLorry_3 = advancedTexture.getControlByName("ButtonLorry_3");   
    let buttonLorry_4 = advancedTexture.getControlByName("ButtonLorry_4");   
    let buttonLorry_5 = advancedTexture.getControlByName("ButtonLorry_5");     
    let buttonLorry_6 = advancedTexture.getControlByName("ButtonLorry_6");

    let inputText_LorryX = advancedTexture.getControlByName("InputText_LorryX");
    let inputText_LorryY = advancedTexture.getControlByName("InputText_LorryY");
    let inputText_LorryZ = advancedTexture.getControlByName("InputText_LorryZ");

    let button_tentOn = advancedTexture.getControlByName("Button_tentOn"); 
    let button_tentOf = advancedTexture.getControlByName("Button_tentOf"); 
    let button_LorrySend = advancedTexture.getControlByName("Button_LorrySend");

    let button_tentTop = advancedTexture.getControlByName("Button_tentTop");    
    let button_tentLeft = advancedTexture.getControlByName("Button_tentLeft");
    let button_tentRight = advancedTexture.getControlByName("Button_tentRight");      
    let button_LorrySend_Camera = advancedTexture.getControlByName("Button_LorrySend_Camera"); 

    

    buttonLorry_1.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_1.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    buttonLorry_2.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_2.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    buttonLorry_3.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_3.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    buttonLorry_4.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_4.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    buttonLorry_5.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_5.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    buttonLorry_6.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_6.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});

    button_tentOn.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_tentOn.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});   
    button_tentOf.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_tentOf.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});  
    button_LorrySend.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_LorrySend.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});  

    button_tentTop.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_tentTop.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});
    button_tentLeft.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_tentLeft.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});  
    button_tentRight.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_tentRight.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});    
    button_LorrySend_Camera.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_LorrySend_Camera.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});   

        buttonLorry_1.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = alphaMatTruck;
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        truck.scaling.x = 1360/truckWidth;
        truck.scaling.y = 260/truckHeight;
        truck.scaling.z = 245/truckDepth;
        truck.position.y = 260/2;

        floor.scaling.x = 1360/floorWidth;
//        floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 245/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - 1360/2, -150, 0);
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + 1360/2, -150, 0);
        buttonLorry_1.background = "#086CA2FF"; buttonLorry_2.background = "#333333FF"; buttonLorry_3.background = "#333333FF";  buttonLorry_4.background = "#333333FF"; buttonLorry_5.background = "#333333FF"; buttonLorry_6.background = "#333333FF";
   
        inputText_LorryX.text = 1360;
        inputText_LorryY.text = 260;
        inputText_LorryZ.text = 245;
      }); 
    
        buttonLorry_2.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = alphaMatTruck;
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        truck.scaling.x = 1650/truckWidth;
        truck.scaling.y = 260/truckHeight;
        truck.scaling.z = 245/truckDepth;
        truck.position.y = 260/2;

        floor.scaling.x = 1650/floorWidth;
 //       floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 245/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - 1650/2, -150, 0);
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + 1650/2, -150, 0);
        buttonLorry_2.background = "#086CA2FF"; buttonLorry_1.background = "#333333FF"; buttonLorry_3.background = "#333333FF";  buttonLorry_4.background = "#333333FF"; buttonLorry_5.background = "#333333FF"; buttonLorry_6.background = "#333333FF";
         
        inputText_LorryX.text = 1650;
        inputText_LorryY.text = 260;
        inputText_LorryZ.text = 245;
      }); 

         
        buttonLorry_3.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = alphaMatTruck;
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        truck.scaling.x = 1360/truckWidth;
        truck.scaling.y = 300/truckHeight;
        truck.scaling.z = 245/truckDepth;
        truck.position.y = 300/2;

        floor.scaling.x = 1360/floorWidth;
 //       floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 245/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - 1360/2, -150, 0); 
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + 1360/2, -150, 0);   
        buttonLorry_3.background = "#086CA2FF"; buttonLorry_1.background = "#333333FF"; buttonLorry_2.background = "#333333FF";  buttonLorry_4.background = "#333333FF"; buttonLorry_5.background = "#333333FF"; buttonLorry_6.background = "#333333FF";   
                 
        inputText_LorryX.text = 1360;
        inputText_LorryY.text = 300;
        inputText_LorryZ.text = 245;
      }); 

         
        buttonLorry_4.onPointerClickObservable.add( () => {
        truckMaterial.alpha = alphaMatTruck; 
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        truck.scaling.x = 1340/truckWidth;
        truck.scaling.y = 239/truckHeight;
        truck.scaling.z = 235/truckDepth;
        truck.position.y = 239/2;

        floor.scaling.x = 1340/floorWidth;
 //       floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 235/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - 1340/2, -150, 0);  
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + 1340/2, -150, 0); 
        buttonLorry_4.background = "#086CA2FF"; buttonLorry_1.background = "#333333FF"; buttonLorry_2.background = "#333333FF";  buttonLorry_3.background = "#333333FF"; buttonLorry_5.background = "#333333FF"; buttonLorry_6.background = "#333333FF";
         
        inputText_LorryX.text = 1340;
        inputText_LorryY.text = 239;
        inputText_LorryZ.text = 235;        
      }); 

         
        buttonLorry_5.onPointerClickObservable.add( () => {
        truckMaterial.alpha = alphaMatTruck; 
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        truck.scaling.x = 1203/truckWidth;
        truck.scaling.y = 239/truckHeight;
        truck.scaling.z = 235/truckDepth;
        truck.position.y = 239/2;

        floor.scaling.x = 1203/floorWidth;
 //       floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 235/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - 1203/2, -150, 0);   
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + 1203/2, -150, 0);
        buttonLorry_5.background = "#086CA2FF"; buttonLorry_1.background = "#333333FF"; buttonLorry_2.background = "#333333FF";  buttonLorry_3.background = "#333333FF"; buttonLorry_4.background = "#333333FF"; buttonLorry_6.background = "#333333FF";
         
        inputText_LorryX.text = 1203;
        inputText_LorryY.text = 239;
        inputText_LorryZ.text = 235;         
      }); 
        
        buttonLorry_6.onPointerClickObservable.add( () => {
        truckMaterial.alpha = alphaMatTruck;
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";  
        truck.scaling.x = 590/truckWidth;
        truck.scaling.y = 239/truckHeight;
        truck.scaling.z = 235/truckDepth;
        truck.position.y = 239/2;

        floor.scaling.x = 590/floorWidth;
 //       floor.scaling.y = 20/floorHeight;
        floor.scaling.z = 235/floorDepth;
        floor.position.y = floorHeight/2;

        boxWeelMove.position = new BABYLON.Vector3(weelPosition - /*590/2*/ 500, -150, 0); 
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + /*59/2*/ 500, -150, 0);
        buttonLorry_6.background = "#086CA2FF"; buttonLorry_1.background = "#333333FF"; buttonLorry_2.background = "#333333FF";  buttonLorry_3.background = "#333333FF"; buttonLorry_4.background = "#333333FF"; buttonLorry_5.background = "#333333FF";
        
        inputText_LorryX.text = 590;
        inputText_LorryY.text = 239;
        inputText_LorryZ.text = 235;        
      });   

        button_tentOn.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = 0.0;
        button_tentOn.background = "#086CA2FF"; button_tentOf.background = "#333333FF";;
        });   

        button_tentOf.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = alphaMatTruck;
        button_tentOf.background = "#086CA2FF"; button_tentOn.background = "#333333FF";;
        });  

        inputText_LorryX.onBeforeKeyAddObservable.add(input => {  // clear if > 9999 cm
        let insert = String(input.text);
        if(insert.length > 3){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 3){input.text = "";};
        });

        inputText_LorryY.onBeforeKeyAddObservable.add(input => {   // clear if > 999 cm
        let insert = String(input.text);
        if(insert.length > 2){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 2){input.text = "";};
        });
        
        inputText_LorryZ.onBeforeKeyAddObservable.add(input => { // clear if > 999 cm
        let insert = String(input.text);
        if(insert.length > 2){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 2){input.text = "";};
        });

        button_LorrySend.onPointerUpObservable.add(function() {
        truckMaterial.alpha = alphaMatTruck; 
        let truckLong = 0;        
        truck.scaling.x = inputText_LorryX.text/truckWidth;
        truck.scaling.y = inputText_LorryY.text/truckHeight;
        truck.scaling.z = inputText_LorryZ.text/truckDepth;
        truck.position.y = inputText_LorryY.text/2;

        floor.scaling.x = inputText_LorryX.text/truckWidth;
  //      floor.scaling.y = inputText_LorryY.text/truckHeight;
        floor.scaling.z = inputText_LorryZ.text/truckDepth;
        floor.position.y = floorHeight/2;



        if(inputText_LorryX.text < 1000) {truckLong = 1000;} //min distance for weel
        else {truckLong = inputText_LorryX.text};
        boxWeelMove.position = new BABYLON.Vector3(weelPosition - truckLong/2, -150, 0);   
        boxLorryMove.position = new BABYLON.Vector3(lorryPosition + truckLong/2, -150, 0);

        buttonLorry_1.background = "#333333FF"; buttonLorry_2.background = "#333333FF"; buttonLorry_3.background = "#333333FF";  buttonLorry_4.background = "#333333FF"; buttonLorry_5.background = "#333333FF"; buttonLorry_6.background = "#333333FF";
        });

        button_tentTop.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = 0.0;
        button_tentTop.background = "#086CA2FF"; button_tentLeft.background = "#333333FF"; button_tentRight.background = "#333333FF";

        camera.radius = 1400;
        camera.alpha = Math.PI / 2;
        camera.beta = 0;
        button_tentOn.background = "#086CA2FF"; button_tentOf.background = "#333333FF";

  //      scene.meshes.forEach(m => m.position.z = value );
        });  

        button_tentLeft.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = 0.0;
        button_tentLeft.background = "#086CA2FF"; button_tentTop.background = "#333333FF"; button_tentRight.background = "#333333FF";

        camera.radius = 1400;
        camera.alpha = Math.PI / 2;
        camera.beta = Math.PI / 2;
        button_tentOn.background = "#086CA2FF"; button_tentOf.background = "#333333FF";



        }); 

        button_tentRight.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = 0.0;
        button_tentRight.background = "#086CA2FF"; button_tentTop.background = "#333333FF"; button_tentLeft.background = "#333333FF";

        camera.radius = 1400;
        camera.alpha = -Math.PI / 2;
        camera.beta = Math.PI / 2;       
        button_tentOn.background = "#086CA2FF"; button_tentOf.background = "#333333FF";
        }); 

        button_LorrySend_Camera.onPointerClickObservable.add( () => { 
        truckMaterial.alpha = alphaMatTruck;
        button_tentOn.background = "#333333FF"; button_tentOf.background = "#086CA2FF";
        button_tentRight.background = "#333333FF"; button_tentTop.background = "#333333FF"; button_tentLeft.background = "#333333FF";

        camera.radius = 2000;
        camera.alpha = Math.PI / 2;
        camera.beta = Math.PI / 3;       
        }); 
       /////////////////right gui end

        ///////////////left gui start

        let buttonLorry_templ = advancedTexture.getControlByName("ButtonLorry_templ");  

        let inputText_addBoxes = advancedTexture.getControlByName("InputText_addBoxes");
        let buttonLorry_addBoxes = advancedTexture.getControlByName("ButtonLorry_addBoxes");  
        
        let inputText_box_X = advancedTexture.getControlByName("InputText_box_X");
        let inputText_box_Y = advancedTexture.getControlByName("InputText_box_Y");
        let inputText_box_Z = advancedTexture.getControlByName("InputText_box_Z");
        let inputText_box_place = advancedTexture.getControlByName("InputText_box_place");
        let inputText_box_weight = advancedTexture.getControlByName("InputText_box_weight");

        let button_Box_Send = advancedTexture.getControlByName("Button_Box_Send"); 
        let button_box_delete = advancedTexture.getControlByName("Button_box_delete");  
        let button_box_place = advancedTexture.getControlByName("Button_box_place");

        buttonLorry_templ.onPointerOutObservable.add(() => {document.body.style.cursor=''});  buttonLorry_templ.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});  
        buttonLorry_addBoxes.onPointerOutObservable.add(() => {document.body.style.cursor=''}); buttonLorry_addBoxes.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});    
        button_Box_Send.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_Box_Send.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});     
        button_box_delete.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_box_delete.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});            
        button_box_place.onPointerOutObservable.add(() => {document.body.style.cursor=''}); button_box_place.onPointerEnterObservable.add(() => {document.body.style.cursor='pointer'});    

        buttonLorry_templ.onPointerClickObservable.add( () => { 
          window.open('template.xlsx', '_blank');
        });   

        let insert = ""; 
        inputText_addBoxes.onPointerClickObservable.add(input => {
        inputText_addBoxes.text = "";      
        });	        
        
        inputText_addBoxes.onPointerOutObservable.add(input => {
        insert = input.text;
        var regular = /,/g;
        insert = insert.replace(regular,".");        
        });		
		
        buttonLorry_addBoxes.onPointerUpObservable.add(function() {
        let arreyBoxes = insert.split('/');
        if(inputText_addBoxes.text == ""){  // if empty text
          arreyBoxes = [0, 0, 0, 0, 0]
        }
        inputText_addBoxes.text = "";
        
        randomBox.forEach(function(item, index, array) {       // delete all boxes 
           item.dispose();    
        });

            randomBox = [];    // null for all, cleare boxes
            randomBoxSum = 0;  // null for all, cleare boxes
            mCyrcle = 0;       // null for all, cleare boxes

        
           boxWidth = [];    // null for all, cleare boxes parametres
           boxHeight = [];
           boxDepth = [];
           boxSumm = [];
           boxName = [];
           boxWeight = [];        
           
           arreyBoxes.forEach(function(item, index, array) {       // insert to parametres of boxes 
            switch(index%5) {           
            case 0: boxWidth.push(item); boxSumm.push(1);
            break;
            case 1: boxDepth.push(item);
            break;
            case 2: boxHeight.push(item); 
            break;
            case 3: boxName.push(item);
            break;
            case 4: boxWeight.push(item);
            break;
            }
           });

        createBoxes (boxWidth, boxHeight, boxDepth, boxName, boxWeight);    
      });


      inputText_box_X.onBeforeKeyAddObservable.add(input => { // clear if > 999 cm
        let insert = String(input.text);
        if(insert.length > 2){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 2){input.text = "";};
        });

      inputText_box_Y.onBeforeKeyAddObservable.add(input => { // clear if > 999 cm
        let insert = String(input.text);
        if(insert.length > 2){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 2){input.text = "";};
        });

        inputText_box_Z.onBeforeKeyAddObservable.add(input => { // clear if > 999 cm
        let insert = String(input.text);
        if(insert.length > 2){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 2){input.text = "";};
        });

        inputText_box_place.onBeforeKeyAddObservable.add(input => { // clear if > 10 symbols
        let insert = String(input.text);
        if(insert.length > 9){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 9){input.text = "";};
        });

        inputText_box_weight.onBeforeKeyAddObservable.add(input => { // clear if > 9999 kg
        let insert = String(input.text);
        if(insert.length > 3){ input.addKey = false} else{input.addKey = true};
        if(insert.length > 3){input.text = "";};
        });


        function deleteAllBoxes() {
          randomBox.forEach(function(item, index, array) {       // delete all boxes 
           item.dispose();    
              });
            randomBox = [];    // null for all, cleare boxes
            randomBoxSum = 0;  // null for all, cleare boxes
            mCyrcle = 0;       // null for all, cleare boxes
           boxWidth = [];    // null for all, cleare boxes parametres
           boxHeight = [];
           boxDepth = [];
           boxSumm = [];
           boxName = [];
           boxWeight = []; 
                     };





      let firstBoxSend = 0;
      button_Box_Send.onPointerUpObservable.add(function() {
        if(firstBoxSend == 0){   // delete all boxes on first click
          deleteAllBoxes();
          firstBoxSend = 1; 
        }

        if(  inputText_box_X.text !== ""
          && inputText_box_Y.text !== ""
          && inputText_box_Z.text !== ""
          && inputText_box_Y.text !== ""
          && inputText_box_place.text !== ""
          && inputText_box_weight.text !== ""          
           ) {  // if not empty text
/*
           boxWidth_1 = [];
           boxHeight_1 = [];
           boxDepth_1 = [];
           boxSumm_1 = [];
           boxName_1 = [];
           boxWeight_1 = []; 
 */                      
           boxWidth[mCyrcle] = inputText_box_X.text;
           boxHeight[mCyrcle] = inputText_box_Y.text;
           boxDepth[mCyrcle] = inputText_box_Z.text;
           boxSumm[mCyrcle] = 1;
           boxName[mCyrcle] = inputText_box_place.text;
           boxWeight[mCyrcle] = inputText_box_weight.text; 

           randomBox[mCyrcle] = BABYLON.MeshBuilder.CreateBox(`randomBox${mCyrcle}`, {   // add box to scene
                width: Math.ceil(boxWidth[mCyrcle]), height: Math.ceil(boxHeight[mCyrcle]), depth: Math.ceil(boxDepth[mCyrcle]),}, scene);

                     textureGround[mCyrcle] = new BABYLON.DynamicTexture("dynamic texture", {width:512, height:256}, scene);   
                     textureContext[mCyrcle] = textureGround[mCyrcle].getContext();
        	           materialGround[mCyrcle] = new BABYLON.StandardMaterial("Mat", scene); 

                 materialGround[mCyrcle].diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                 materialGround[mCyrcle].specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                 materialGround[mCyrcle].emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());  

                      materialGround[mCyrcle].diffuseTexture = textureGround[mCyrcle]; 
                      randomBox[mCyrcle].material = materialGround[mCyrcle];
                 randomBox[mCyrcle].material.diffuseTexture.drawText(`${boxName[0]}`, 100, 150, font, "black", "white", true, true);
                 randomBox[mCyrcle].position = new BABYLON.Vector3(200*mCyrcle/4-500, boxHeight[0]/2, 200*(mCyrcle%4)+300);

                 meshWidth = createTextSizeBoxes(48, boxWidth[mCyrcle]/5, boxWidth[mCyrcle], boxWidth[mCyrcle]/4, boxHeight[mCyrcle]/2 + 0.4, - boxDepth[mCyrcle]/2 + boxWidth[mCyrcle]/10, Math.PI/2, Math.PI, 0); 
                 meshWidth.isPickable = false; 
                 meshWidth.parent = randomBox[mCyrcle];

                 meshDepth = createTextSizeBoxes(48, boxDepth[mCyrcle]/5, boxDepth[mCyrcle], boxWidth[mCyrcle]/2 - boxDepth[mCyrcle]/10, boxHeight[mCyrcle]/2 + 0.4, 0, Math.PI/2, -Math.PI/2, 0); 
                 meshDepth.isPickable = false; 
                 meshDepth.parent = randomBox[mCyrcle];    
            
                 randomBox.sort((a,b)=>( a.position.y - b.position.y )) // kod work mach better

            mCyrcle = mCyrcle + 1;

          };               
        //     console.log(mCyrcle);                   
      });

        button_box_delete.onPointerClickObservable.add( () => {   
          deleteAllBoxes() 
        }); 

/////////////////////////// placing start

        button_box_place.onPointerClickObservable.add( () => {
          if(mCyrcle > 0){ // if are boxes

          truck_Depth = 1650; // truck
          truck_Width = 300;

          scene.meshes.forEach((mesh)=>{ // get trucks parametres
          if(mesh.name === "truck") {
            truck_Depth = 2*mesh.getBoundingInfo().boundingBox.maximum.x * mesh.scaling.x;
            truck_Width = 2*mesh.getBoundingInfo().boundingBox.maximum.z * mesh.scaling.z;
          }  
            })  

  //        console.log(truck);  
  //        console.log(truck_Depth);  
  //        console.log(truck_Width);    

          let ostPoZ = truck_Width;  // текущий остаток от ширины фуры.
          let ostPoDlinFur = truck_Depth;  // текущий остаток от длины всей фуры.
          let visRiadaX = 0;  //  first box width.

         let boxAll = [];       // all boxes
         let  boxPlacing = [];  // order boxes 

         let  boxRow = [];      // row of boxe    
         let  boxColumn = [];   // column of box

               let maxBoxZ = 0;  // текущий максимум длины коробки
               let numBox;     // number of box

               let boxX;  // текущая ширина коробки
               let boxZ;  // текущая длина коробки
               let nalichieBoxa; // if there are boxes
 


               let dlinaZ = [];
               let shirinaX = [];

               for (let i = 0; i < mCyrcle; i++) { // define arrey "boxAll" from 0 to mCyrcle
               boxAll[i] = i;
               };

               for (let i = 0; i < boxAll.length; i++) {  
               randomBox.forEach(function(item, index, array) {   // observ scene, find boxes
               if(item.name == `randomBox${i}`) {
                dlinaZ[i] = 2*item.getBoundingInfo().boundingBox.maximum.z;   // get size of box - length
                shirinaX[i] = 2*item.getBoundingInfo().boundingBox.maximum.x;   // get size of box - width               
               }  
               });              
               }

    //           console.log(`boxAll: ${boxAll}`); 
               let boxAll_0 = boxAll;

                     function upgrade(array, num, row, column) {   // удаляем из массива элемент и записываем в массив для размещения + ряд и колонку.
                      let indexArray = array.indexOf(num);
                      if (indexArray > -1) { // only splice array when item is found
                        array.splice(indexArray, 1); // 2nd parameter means remove one item only
                      }
                      boxPlacing.push(num); 
                      boxRow.push(row);    
                      boxColumn.push(column); 
                     };
                     

            for (let row = 0; row < 1000; row++) {      ///////////cycle for row


             for (let k = 0; k < 500; k++) {      ///////////cycle for column
                 if(k == 0) { 
                maxBoxZ = 0;
                boxAll.forEach(function(item, index, array) {

                boxZ = dlinaZ[item];   // get size of box - length
                boxX = shirinaX[item];   // get size of box - width   
                 if(maxBoxZ < boxZ && boxZ <= truck_Width) { 
                  maxBoxZ = boxZ; 
                  numBox = item;
                  visRiadaX = boxX;

                }    // текущий максимум ширины и номер коробки

                 
              });

                 ostPoZ = ostPoZ - maxBoxZ;
                 upgrade(boxAll, numBox, row , k);  //array, num, row, column                    
                }  // запоминаем высоту К ряда 
                    
                 else {
                  maxBoxZ = 0; // обнуляем макс длину текущего бокса
                  nalichieBoxa = 0;
                  boxAll.forEach(function(item, index, array) {
                  boxZ = dlinaZ[item];   // get size of box - length
                  boxX = shirinaX[item];   // get size of box - width 

                  if(visRiadaX >= boxX && ostPoZ >= boxZ && maxBoxZ < boxZ && ostPoDlinFur > visRiadaX) { 
                    maxBoxZ = boxZ; 
                    numBox = item;
                    nalichieBoxa = 1;                    
                  }    // текущий максимум ширины и номер коробки 
              }); 
                  if(nalichieBoxa == 1){
                  ostPoZ = ostPoZ - maxBoxZ;                          
                  upgrade(boxAll, numBox, row , k);  //array, num, row, column  
                  } else {
                    ostPoZ = truck_Width; 
                    ostPoDlinFur = ostPoDlinFur - visRiadaX;
                    visRiadaX = 0;
                    break; }
                 }
          };       ////////////////////////////  цикл для колонок

          if(ostPoDlinFur < truck_Width/2 || boxPlacing.length >= mCyrcle) { 
            break;}

        };       ////////////////////////////  цикл для рядов

     //            console.log(`boxPlacing: ${boxPlacing}`);
    //             console.log(`boxAll: ${boxAll}`);                

                 dl=[];        //длина коробки по Z
                 sh=[];        // ширина коробки по X
                 boxPlacing.forEach(function(item, index, array) {
                  dl[index] = dlinaZ[boxPlacing[index]];
                  sh[index] = shirinaX[boxPlacing[index]];
              //    console.log(boxPlacing[item]);                 
                 });
   //              console.log(`dl:${dl}`);
   //              console.log(`dlinaZ:${dlinaZ}`);

   //              console.log(`sh:${sh}`);
   //              console.log(`shirinaX:${shirinaX}`);

         //        console.log(boxRow);   
      //           console.log(boxColumn);
        

                let sdvigZ = 0;
                let sdvigX = 0; 
                boxPlacing.forEach(function(item, index, array) { 
            //    for (let i = 0; i < boxPlacing.length; i++) {                
                   
    //             console.log(randomBox[boxPlacing[index]].name);

                 if(boxColumn[index] == 0)  
                 { 
                  sdvigZ = 0;
                  randomBox[boxPlacing[index]].position.z = dl[index]/2 - truck_Width/2 + 0.3;
                  randomBox[boxPlacing[index]].position.x = sdvigX + sh[index]/2 - truck_Depth/2 + 0.3;
                  sdvigZ = dl[index];
                  sdvigX = sdvigX + sh[index];

                 } 
                 else{

                  randomBox[boxPlacing[index]].position.z = sdvigZ + dl[index]/2 - truck_Width/2 + 0.3;
                  randomBox[boxPlacing[index]].position.x = sdvigX - sh[index]/2 - truck_Depth/2 + 0.3;
                  sdvigZ = sdvigZ + dl[index];                  
                 }
                

               // }
              });

            }
/////////////////////////////////drowing replacing end

        });

 /////////////////////////// placing end       

    ////////////////left gui end


// add Inspector start  Shift+Ctrl+Alt+I
async function addInspectorForScene(scene) {
    const switchDebugLayer = () => {
      if (scene.debugLayer.isVisible()) {
        scene.debugLayer.hide();
      } else {
        scene.debugLayer.show({ overlay: true });
      }
    };
  
    // hide/show the Inspector
    window.addEventListener("keydown", async (ev) => {
      // Shift+Ctrl+Alt+I
      if (ev.shiftKey && ev.ctrlKey && ev.altKey && ev.keyCode === 73) {
        const debuggerScript = document.querySelector("script[inspector]");
  
        if (!debuggerScript) {
          console.log(`Start loading inspector...`);
          const s = document.createElement("script");
          s.setAttribute("inspector", "true");
          s.src =
            "https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js";
  
          s.onload = () => {
            console.log(`Inspector loaded!`);
            switchDebugLayer();
          };
          s.onerror = () => {
            console.log(`Inspector failed to load`);
          };
          document.body.appendChild(s);
          return;
        }
  
        switchDebugLayer();
      }
    });
  }
  
  addInspectorForScene(scene);

// add Inspector  Shift+Ctrl+Alt+I end

            return scene;
        };
                window.initFunction = async function() {
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => {
             sceneToRender = returnedScene; });                           
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
